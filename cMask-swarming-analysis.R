cMask <- function(folder_name){
  
  # This code takes a stack of images of growing biofilms (grayscale jpgs) and identifies and measures the area
  # of the swarming colony in each image.  This is computationally difficult because the swarms are very transparent
  # and often do not have clear boundaries - especially as the swarms get larger.
  
  # The spreading rate is eventually extracted from the data generated by this script.
  
  #Must switch to R 3.2.1 for bioOS package to work!
  
  #Use this function after run_Dhruvcode.R, which generates the first mask, which removes the non-plate areas.
     #in Dhruv_code folder (C:\Users\Kenyon\Documents\Bacillus_subtilis\swarming plates\R swarming\Dhruv_code)
  # added second background subtraction, 4/14/16
  
  #Example input photos and sample outputs can be found here-
      # https://drive.google.com/open?id=0B6wJlSJAzF3wNV9Ha1FSNFhtNEU
  
  #Necessary inputs:
  # 1) Name of experiment folder  (folder_name) - ie, run > cMask("folder name")
      #1b) Needs to contain a folder named "grayscale"
  # 2) Directory path to experiment folder
  # 3) Need to have generated "Dmask", a mask that finds the 4 plates and removes the other areas of the photos,
  #    generated by run_Dhruvcode.R
  
  #Outputs:
  # 1) folder "tiled_masks", which shows the image output of each processed image at 6 intermediate steps
  # 2) folder "background_subtracted", which holds full-sized versions of the colonies after the background
      # subtraction steps
  # 2) allmlistxxxx.rds - RDS file of lists of output for each image:
       # x- and y-coordinates of each identified swarm, and pixel area
  # 3) refplatexxxx.tiff - labeled image showing which swarm was assigned which numeric reference label
  # 4) csv of the pixel area of each identified swarm in all images in which it was found
  # 5) pdf plot of the data in the above csv, showing the discovered area of each identified swarm by image number

  # Load scripts and Libraries
  library("EBImage")
  library("biOps")
  #load EBI2biOps.R
  source('~/Bacillus_subtilis/swarming plates/R swarming/Swarming_Example/EBI2biOps.R')
  
  setwd = setwd("C:/Users/Kenyon/Documents/Bacillus_subtilis/swarming plates/")
  maindir = "C:/Users/Kenyon/Documents/Bacillus_subtilis/swarming plates/R swarming/Swarming_Example" 
  if(file.exists(maindir)==FALSE) stop(" 'maindir' path does not exist, check line 37 for typos")
  
  picdir = paste(maindir,folder_name,"input","grayscale",sep="/")   #used to load images
  filelistL <- list.files(picdir, "jpg")  
  if(length(filelistL)<2) stop(paste0("picdir incorrectly found, check line 40 for typos"))
  
  bck=7  # photo to use for first background subtraction (7th image in stack)
  frst=12  # first photo to analyze; usually aim for 5-10 photos before colonies become detectable
  LL=60    #last image in stack to analyze
 
  # Generate Dmask
  Dmask_path<-list.files(paste(maindir,folder_name,"input",sep="/"),pattern = "*-mask.jpg")
  if(length(Dmask_path)!=1) stop("First mask file not uniquely identified")
  Dmask<-readImage(paste(maindir,folder_name,"input",Dmask_path,sep="/"))
  
  # Set directory information for loading and saving images
 
             #list of pic file names
  
  if(length(filelistL)<LL) stop(paste0("LL is longer than number of images in ",folder_name,"/grayscale"))
  
  # get reference mask from first photo
  paramed1 <- readImage(paste(picdir,"/",filelistL[bck],sep=""))
  paramed<-paramed1*Dmask
  #this is where the background slide is read and identified
  
  #creat empty objects
  allmlist <- list()
  mlist <- c()
  
#Begin major for-loop that processes each image:
  
  for (x in frst:LL) {   
    para1 <- readImage(paste(picdir,"/",filelistL[x],sep=""))
    para<-para1*Dmask
    
    #print number of images left to process
    print(paste0("---img #",(1+x-frst)," of ",(LL-frst+1),"---"))
    
    # Background subtraction
    print("0. Background Subtraction")
    paranobg<- (para-paramed)
    
    #Subtract first generated image from all, after subtracting background image
    if(x==frst){pbg1<-paranobg}
    paranobg<-paranobg-pbg1
    
    #create tiled images
    width<-dim(para)[1]/4   #dimension to be used for tiled image at end of loop
    paraout<-resize(para,w=width) #resize for tiled image
    
    #change neg values from background subtraction back to 0
    print("1. remove neg values")
    par0<-as.matrix(paranobg)
    par0[par0<0]<-0
    par0<-as.Image(par0)
    
    #amplify stronger signals using gamma correction
    print("2. gamma correction")
    par0<-(par0^0.3)
    
    #some global thresholding of weak signals to zero
    print("3. remove weak noises")
    par0<-as.matrix(par0)
    par0[par0<0.23]<-0
    par0<-as.Image(par0)
    paraout2<-resize(par0*(0.3/mean(par0)),w=width)  #increase contrast in output image, and resize
    
    #save parout2 to folder
    t0_loc<-file.path(paste0(maindir,"/",folder_name,"/output"), "bckgnd_subtracted")
    dir.create(t0_loc, showWarnings = FALSE)
    writeImage(par0*(0.3/mean(par0)), file=paste(t0_loc, paste0("img",x,"_",substr(filelistL[x],1,nchar(filelistL)-4),"_bck.png")
                              , sep="/"))
    
    #blur image a bit to get rid of noise
    print("4. running filter2")
    f = makeBrush(11, shape='diamond', step=FALSE)
    f = f/sum(f)
    filt2<-filter2(par0,f)
 
    filt2print<-resize(filt2*(0.3/mean(filt2)),w=width)  #increase contrast in output image
    
    
    #generate first mask; now image is binary
    print("5. make mask1")
    mask1<-thresh(filt2,w=550,h=550,offset=0.045)
    #rm(filt2)
    
    
    #mask2: dilate and then erode to remove more noise/fill in small gaps:
    print("6. make mask2")
    kern <- makeBrush(9, shape='diamond')
    mask2 <- closing(opening(mask1, kern), kern)
   
    #mask3: fill-in small holes with "fillHull"
    print("7. make mask3")
    mask3 <- fillHull(bwlabel(mask2))  
    
    mask1out<-resize(mask1,w=width)  #for output image
   
    
  print("8. run first computeFeatures")
   m <- computeFeatures.moment(mask3)
   m2 <- computeFeatures.shape(mask3)
   m <- cbind(m2[,'s.area'],m)
  
    
    if (length(m) != 0) {
      colnames(m)[1] <- "m.pxs"   
      

      low = 6000  # initial colony size appears to be about 8000 pixels

      id<-which(m[,'m.pxs']<low | m[,'m.eccentricity'] > 0.65 | m[,'m.majoraxis']>1050 |m[,'m.pxs']>710000)  #1050 major axis is about size of plate
      
      mask4 <- rmObjects(mask3, id)  #removes objects that satisfy any conditions of "id"
      mask3out<-resize(mask3,w=width)
      
      #save image 40 for reference image
      if(x==40){
        writeImage(mask4, file=paste(maindir, paste0("mask4",folder_name,".jpg",sep="")
                                     , sep="/"))
            }
      
      print("9. running computeFeatures 2")
      m <- computeFeatures.moment(mask4)
      m2 <- computeFeatures.shape(mask4)
      m<- cbind(m2[,'s.area'],m)
      
      
      #make tiled image and write to drive
      mask4out<-resize(mask4,w=width) #for output image
      
    if (length(m) != 0) {
        colnames(m)[1] <- "m.pxs"
        
        mlist=m[,c('m.cx','m.cy', 'm.pxs')]
        #mlist[(nrow(mlist) +1)] <- c(0, 0, 0)
        allmlist[[x]] <- mlist 
        print("10. colonies found")
      }else{
        allmlist[[x]]<-NULL
        print("10. no real objects found")}
      
      
    }else{
      allmlist[[x]]<-NULL
      print("9. no objects found")
      mask3out<-resize(mask3,w=width)
      mask4out<-mask3out  }
   
   
   #generate output image
   
   t1<-tile(combine(paraout,paraout2,filt2print,mask1out,mask3out,mask4out),nx = 3)
   
   t1_loc<-file.path(paste0(maindir,"/",folder_name,"/output"), "tiled_masks")
   dir.create(t1_loc, showWarnings = FALSE)
   writeImage(t1, file=paste(t1_loc, paste0("img",x,"_",substr(filelistL[x],1,nchar(filelistL)-4),"_tile.png")
                             , sep="/"))
   gc()
    
    
  }  #end for_loop going through each picture iteratively
  print("END for-loop")
  
  #save allmlist file
  saveRDS(allmlist,file=paste(maindir,folder_name,"output",paste0("allmlist_",folder_name,".rds"),sep="/"))

  # calculate center of objects;
  #need image that has the 4 colonies -
  # find 6th image with 4 objects, or if that doesn't exist, try img 27
  limg<-which(summary(allmlist)[,1]==(3*4))[6]  #four colonies * four data on each = length of entry
  
  m<-ifelse(is.na(allmlist[[limg]]),allmlist[[27]],allmlist[[limg]]) 


  ## Print tiff of last plate's labeled with reference numbers
  
      #Print image of mask4 from last photo
      label  <- as.character(c(1:nrow(m)))
      xy=m[,c('m.cx','m.cy')]
      xyadj <- xy
      xyadj[,'m.cx'] <- 4  #changed from -4
      xyadj[,'m.cy'] <- 0
      xy1 <- xy + xyadj
      xy1[,'m.cy'] <- ncol(paramed) - xy1[,'m.cy']
      
      
      mask40<-readImage(paste(maindir, paste0("mask4",folder_name,".jpg",sep=""), sep="/"))
      tiff(paste0(maindir,"/",folder_name,"/output/","refplate_",folder_name,".tiff"), width = dim(mask40)[1], height = dim(mask40)[2])
      par(mar=c(0, 0, 0, 0))
      plot(EBI2biOps(mask40>0))
      text(x=xy1[,1],y=xy1[,2],labels=as.character(label),col="blue",cex=4)
      dev.off()
      rm(mask40)
      print("numbered tiff image generated")
  
  ##collect data from each photo, put into dataframe, and plot
  
  pdlist <- NULL  
  
  for (i in 1:nrow(allmlist[[limg]])) {  #for "i", the number of objects found in limg -
    
    x <- as.double(allmlist[[limg]][i,'m.cx'])
    y <- as.double(allmlist[[limg]][i,'m.cy'])
    p <- as.double(allmlist[[limg]][i,'m.pxs'])
    
    for (j in frst:length(allmlist)){ 

      if (is.null(allmlist[[j]])==FALSE){
        
        
        #if there is only one entry, the class of the object changes to "numeric", 
        #which is not accessible by the same indexing notation
        
        if(class(allmlist[[j]])=="numeric"){
          xj<-allmlist[[j]][1]
          yj<-allmlist[[j]][2]
          pxj<-allmlist[[j]][3]
          
        }else if(class(allmlist[[j]])=="matrix"){
          xj<-allmlist[[j]][,'m.cx']
          yj<-allmlist[[j]][,'m.cy']
          pxj1<-allmlist[[j]][,'m.pxs']
          
          mincol <- which.min((abs(xj - x))^2 + (abs(yj - y))^2)
          pxj<-allmlist[[j]][mincol,'m.pxs']
          
        }
        
        #calculates distances between all objects in J and object "i" in limg, and reports dist to closest one
        mindist <- min((abs(xj - x))^2 + (yj - y)^2)
        
        
        if (mindist <= 1000){  #if the distance is less than 500  #changed to 1000 on 8/20 for MN set
          pd <- c(i,j,pxj,mindist) #(LL obj, j# photo, m.pxs, dist)
          pdlist<-rbind(pdlist,pd)
              }
        
          }#end if-null clause
        print(j)
        }#end j-loop
      
    }#end i-loop
  
  
  #save all measurements of colony objects in csv
  colnames(pdlist)<-c("object","img","pxls","er.dist")
  write.csv(pdlist, file=paste(maindir,folder_name,"output",paste(folder_name,"_swarmdata",".csv",sep=""),sep="/" ))
  print("colony data csv printed")
  
  #plot and save PDF of colony pixel area vs image#
  pdf(file=paste0(maindir,"/",folder_name,"/output/",folder_name,'_swarmplot','.pdf'))
  #windows(40,60)
  plot(pdlist[,3]~pdlist[,2],col=pdlist[,1],xlab = "photo #",ylab="pixel area")
  legend('topleft',names(table(pdlist[,1])),xpd=TRUE, pch=1, 
         col = as.numeric(levels(as.factor(pdlist[,1]))),inset = c(0, 0))
  dev.off()
  print("growth rate pdf generated")
  
  
  return(pdlist) 
  
}